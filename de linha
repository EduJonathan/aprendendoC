[1mdiff --git "a/C/basico/08_ponteiros/memoria vari\303\241veis e ponteiros.txt" "b/C/basico/08_ponteiros/memoria vari\303\241veis e ponteiros.txt"[m
[1mindex 543a1df..761a89a 100644[m
[1m--- "a/C/basico/08_ponteiros/memoria vari\303\241veis e ponteiros.txt"[m	
[1m+++ "b/C/basico/08_ponteiros/memoria vari\303\241veis e ponteiros.txt"[m	
[36m@@ -35,20 +35,22 @@[m [ma l√≥gica se aplica a todos os tipos de dados, por√©m que varia de acordo com su[m
 -------------------------------[m
 ## ‚ùì E o ponteiro?[m
 [m
[31m-O ponteiro √© uma vari√°vel especial recebendo os mesmos atributos de uma vari√°vel qualquer[m
[31m-(endere√ßo, nome, e um valor), mas com uma pequena diferen√ßa em vez de armazenar diretamente[m
[31m-um valor, ela armazena o endere√ßo de mem√≥ria onde o valor est√° localizado. [m
[31m-Isso permite manipular dados de uma forma mais flex√≠vel e eficiente, principalmente ao trabalhar [m
[31m-com grandes estruturas de dados ou em fun√ß√µes onde precisamos alterar diretamente o valor de vari√°veis.[m
[32m+[m[32mUm ponteiro √© uma vari√°vel como qualquer outra, mas, em vez de armazenar diretamente um valor,[m[41m [m
[32m+[m[32mele armazena o endere√ßo de mem√≥ria onde esse valor est√° localizado. Isso significa que, ao[m[41m [m
[32m+[m[32mtrabalhar com ponteiros, podemos acessar diretamente o valor armazenado em outra parte da mem√≥ria,[m[41m [m
[32m+[m[32mao inv√©s de fazer uma c√≥pia do dado.[m
[32m+[m[32mIsso permite manipular dados de uma forma mais flex√≠vel e eficiente, principalmente[m[41m [m
[32m+[m[32mao trabalhar com grandes estruturas de dados ou em fun√ß√µes onde precisamos alterar diretamente[m[41m [m
[32m+[m[32mo valor de vari√°veis.[m
 [m
 - int x = 10;[m
 - int *p = &x; // Declarando e passando o endere√ßo de 'x' para o ponteiro que agora[m
     [m
[31m-    int *p                                                  int x[m
[32m+[m[32m    int *p               aponta para o endere√ßo de x          int x[m
 -----------------------                               -----------------------[m
 | endere√ßo | conte√∫do |                               | endere√ßo | conte√∫do |[m
 -----------------------                               -----------------------[m
[31m-| 0x1050   |          | p aponta para o endere√ßo de x | 0x1040   | 00001010 | <- valor 10[m
[32m+[m[32m| 0x1050   |          |                               | 0x1040   | 00001010 | <- valor 10[m
 -----------------------                               -----------------------[m
 | 0x1054   |          |                               | 0x1044   |          |[m
 -----------------------                               -----------------------[m
[36m@@ -75,21 +77,12 @@[m [mtornando o c√≥digo mais eficiente e flex√≠vel. Eles s√£o usados para:[m
 ‚Ä¢ Acessar diretamente hardware e trabalhar com sistemas embarcados.[m
 [m
 Essa flexibilidade √© o que torna C/C++ t√£o poderosa, mas tamb√©m exige um cuidado extra,[m
[31m-j√° que o gerenciamento manual da mem√≥ria(mesmo com limita√ß√µes, a manipula√ß√£o de ponteiros[m
[31m-em C aproxima o programador de uma intera√ß√£o com a mem√≥ria de baixo n√≠vel, o que √© o mais[m
[32m+[m[32mj√° que o gerenciamento manual da mem√≥ria(mesmo com limita√ß√µes, a manipula√ß√£o de ponteiros[m[41m [m
[32m+[m[32maproxima o programador de uma intera√ß√£o com a mem√≥ria de baixo n√≠vel, o que √© o mais[m
 pr√≥ximo que se pode chegar de trabalhar com linguagem de m√°quina em termos de controle e [m
 acesso direto √† mem√≥ria) e esta manipula√ß√£o direta de ponteiros podem levar a erros dif√≠ceis [m
[31m-de rastrear, pois ainda trabalhamos com a abstra√ß√£o, diferentes de outras linguagens como Assembly.[m
[31m-[m
[31m--------------------------------[m
[31m-## ‚ùì Por que os dados s√£o armazenados em bin√°rio?[m
[31m-[m
[31m-Computadores operam com circuitos eletr√¥nicos que t√™m dois estados b√°sicos: ligado (1) [m
[31m-e desligado (0). Esses estados s√£o facilmente representados fisicamente com transistores, [m
[31m-tornando o bin√°rio (0s e 1s) a forma mais eficiente de representar qualquer tipo de dado [m
[31m-(n√∫meros, letras, imagens, at√© os endere√ßos). Para facilitar a compreens√£o humana, [m
[31m-esses valores bin√°rios s√£o frequentemente convertidos por conta dos formatadores(%d) [m
[31m-para formatos como decimal ou hexadecimal.[m
[32m+[m[32mde rastrear, pois ainda trabalhamos com a abstra√ß√£o de nomes de tipos de dados(estando ponteiros[m
[32m+[m[32mneste meio), diferentes de outras linguagens como Assembly.[m
 [m
 -------------------------------[m
 ## üí≠Ponteiros n√£o s√£o "endere√ßos que armazenam endere√ßos".[m
[36m@@ -100,3 +93,33 @@[m [mO endere√ßo 0x1050 do ponteiro `p`, o fato do ponteiro est√° armazenado em um en[m
 apenas uma consequ√™ncia da forma de como a mem√≥ria √© organizada nos computadores, onde [m
 todas as vari√°veis (sejam ponteiros, structs, ou outros tipos de dados) precisam ser [m
 alocadas em endere√ßos f√≠sicos.[m
[32m+[m
[32m+[m[32m-------------------------------[m
[32m+[m[32m## ‚ùì Por que C tem ponteiros?[m
[32m+[m
[32m+[m[32mO motivo mais plaus√≠vel de C ter ponteiros √© devido ao seu alicerce de portabilidade,[m
[32m+[m[32mflexibilidade e oferecer aspectos ao acesso de baixo n√≠vel, a linguagem C √© de alto n√≠vel[m
[32m+[m[32mpois foi criada para ter uma compreens√£o humana mais vis√≠vel(isso no seu tempo de cria√ß√£o),[m[41m [m
[32m+[m[32mmuitos confudem a linguagem de ser **medium n√≠vel** devido a esse acesso ao baixo n√≠vel,[m[41m [m
[32m+[m[32mmas eu n√£o acredito pois a computa√ß√£o sempre demonstrou ser amb√≠go, porque algo iria[m[41m [m
[32m+[m[32mquebrar esta regra, ponteiros em C existem principalmente para dar ao programador um[m[41m [m
[32m+[m[32mcontrole direto sobre a mem√≥ria.[m
[32m+[m
[32m+[m[32m-------------------------------[m
[32m+[m[32m## ‚ùì Por que n√£o existe um tipo especial para definir ponteiros?[m
[32m+[m
[32m+[m[32mA raz√£o pela qual C n√£o tem um tipo especial chamado `pointer` √© que os ponteiros em C s√£o,[m[41m [m
[32m+[m[32mna verdade, tipos de dados parametrizados, ou seja, um ponteiro em C √© um tipo que aponta[m[41m [m
[32m+[m[32mpara um dado de um tipo espec√≠fico, como int *, char *, float *, e al√©m disso, o tipo[m[41m [m
[32m+[m[32m`void *` oferece a flexibilidade de um ponteiro gen√©rico, permitindo o uso de ponteiros[m[41m [m
[32m+[m[32msem uma defini√ß√£o de tipo exato.[m
[32m+[m
[32m+[m[32m-------------------------------[m
[32m+[m[32m## ‚ùì Por que os dados s√£o armazenados em bin√°rio?[m
[32m+[m
[32m+[m[32mComputadores operam com circuitos eletr√¥nicos que t√™m dois estados b√°sicos: ligado (1)[m[41m [m
[32m+[m[32me desligado (0). Esses estados s√£o facilmente representados fisicamente com transistores,[m[41m [m
[32m+[m[32mtornando o bin√°rio (0s e 1s) a forma mais eficiente de representar qualquer tipo de dado[m[41m [m
[32m+[m[32m(n√∫meros, letras, imagens, at√© os endere√ßos). Para facilitar a compreens√£o humana,[m[41m [m
[32m+[m[32messes valores bin√°rios s√£o frequentemente convertidos por conta dos formatadores(%d)[m[41m [m
[32m+[m[32mpara formatos como decimal ou hexadecimal.[m
[1mdiff --git a/C/basico/09_funcoes/1_functions/10_pilha_de_chamada.c b/C/basico/09_funcoes/1_functions/10_pilha_de_chamada.c[m
[1mindex f06f3ab..b3af918 100644[m
[1m--- a/C/basico/09_funcoes/1_functions/10_pilha_de_chamada.c[m
[1m+++ b/C/basico/09_funcoes/1_functions/10_pilha_de_chamada.c[m
[36m@@ -10,7 +10,7 @@[m
  * Entender a pilha de chamada faz com que seu c√≥digo tenha performance para com o custo[m
  * de menos mem√≥ria, pois fun√ß√µes que possam tratar de c√°lculos muitos complexo, ainda[m
  * mais em fun√ß√µes recursiva infinitas que podem gerar "stack overflow"(estouro de pilha)[m
[31m- * e tamb√©m reduzir a profundidade da para economizar pilha, otimizanod com[m
[32m+[m[32m * e tamb√©m reduzir a profundidade da para economizar pilha, otimizando com[m
  * ("tail call optimization").[m
  */[m
 [m
[36m@@ -40,6 +40,38 @@[m [mvoid funcaoA()[m
     funcaoB();[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Ir√° inserir o ano que o usu√°rio nasceu e retorna-lo[m
[32m+[m[32m */[m
[32m+[m[32mint lerAno()[m
[32m+[m[32m{[m
[32m+[m[32m    int ano = 0;[m
[32m+[m[32m    printf("Digite o ano que voc√™ nasceu: ");[m
[32m+[m[32m    scanf("%d", &ano);[m
[32m+[m[32m    return ano;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Ir√° calcular o ano que o usu√°rio nasceu e com o ano atual(2025) retornando a idade[m
[32m+[m[32m *[m
[32m+[m[32m * @param ano Pega o ano que o usu√°rio nasceu[m
[32m+[m[32m */[m
[32m+[m[32mint calcularIdade(int ano)[m
[32m+[m[32m{[m
[32m+[m[32m    int idade = 2025 - ano;[m
[32m+[m[32m    return idade;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Ir√° apresentar a idade do usu√°rio[m
[32m+[m[32m *[m
[32m+[m[32m * @param idade Par√¢metro para informar e apresentar a idade do usu√°rio[m
[32m+[m[32m */[m
[32m+[m[32mvoid suaIdadeE(int idade)[m
[32m+[m[32m{[m
[32m+[m[32m    printf("Voc√™ tem: %d", idade);[m
[32m+[m[32m}[m
[32m+[m
 int main(int argc, char **argv)[m
 {[m
     funcaoA();[m
[36m@@ -51,5 +83,9 @@[m [mint main(int argc, char **argv)[m
      *          |--------funcaoB()[m
      *                  |--------funcaoC()[m
      */[m
[32m+[m
[32m+[m[32m    int ano = lerAno(); // A fun√ß√£o s√≥ ir√° sair ap√≥s o valor de entrada[m
[32m+[m[32m    int idade = calcularIdade(ano);[m
[32m+[m[32m    suaIdadeE(idade);[m
     return 0;[m
 }[m
[1mdiff --git a/C/headers/02_strings_e_caracteres/3_header_wchar.h/wchar.txt b/C/headers/02_strings_e_caracteres/3_header_wchar.h/wchar.txt[m
[1mindex 53e0a75..6f7c377 100644[m
[1m--- a/C/headers/02_strings_e_caracteres/3_header_wchar.h/wchar.txt[m
[1m+++ b/C/headers/02_strings_e_caracteres/3_header_wchar.h/wchar.txt[m
[36m@@ -1,4 +1,5 @@[m
[31m-Explicando o wchar_t em C:[m
[32m+[m[32m----------------------------------------------------[m
[32m+[m[32müìå wchar_t:[m
 O tipo wchar_t em C √© utilizado para representar **caracteres largos**, permitindo [m
 armazenar e manipular **caracteres Unicode** e outros conjuntos de caracteres multibyte [m
 que n√£o podem ser representados com o tipo char.[m
[36m@@ -11,7 +12,7 @@[m [mcaracteres, como chin√™s, √°rabe, russo ou emojis, precisamos de um tipo que pos[m
 mais informa√ß√µes.[m
 [m
 ----------------------------------------------------[m
[31m-O que √© wchar_t?[m
[32m+[m[32müìå O que √© wchar_t?[m
 - wchar_t: √© um tipo de dado especial em C, utilizado para armazenar caracteres largos, [m
 ou seja, caracteres de m√∫ltiplos bytes.[m
 [m
[36m@@ -22,7 +23,7 @@[m [mou seja, caracteres de m√∫ltiplos bytes.[m
 conjunto Unicode, como UTF-16 ou UTF-32.[m
 ----------------------------------------------------[m
 [m
[31m-Por que usar wchar_t:[m
[32m+[m[32m‚ùì Por que usar wchar_t:[m
 O uso de wchar_t √© vantajoso quando trabalhamos com texto multilingue ou quando a [m
 aplica√ß√£o precisa de suporte a conjuntos de caracteres que n√£o s√£o represent√°veis com o [m
 tipo char. Por exemplo, em uma aplica√ß√£o que manipula texto em chin√™s ou japon√™s, √© [m
[36m@@ -30,7 +31,7 @@[m [mnecess√°rio usar wchar_t para representar caracteres que exigem mais de um byte.[m
 [m
 ----------------------------------------------------[m
 [m
[31m-Como utilizar na linguagem C:[m
[32m+[m[32müìå Como utilizar na linguagem C:[m
 [m
 Os include <wchar.h> e <wctype.h>, n√£o se diferencia muito dos includes <string.h> e <ctype.h>, [m
 praticamente as mesmas fun√ß√µes com mesmos prop√≥sitos(strlen, strcpy, wcslen, wcscpy),[m
[36m@@ -44,7 +45,7 @@[m [mmaneira semelhante ao que voc√™ faria com strings padr√£o (do tipo char*), mas c[m
 dados wchar_t.[m
 ----------------------------------------------------[m
 [m
[31m-Significado do s√≠mbolos Unicode:[m
[32m+[m[32müìå Significado do s√≠mbolos Unicode:[m
 [m
 Sim, o Unicode cont√©m uma vasta gama de s√≠mbolos e caracteres para representar diferentes[m
 tipos de caracteres, incluindo caracteres largos (ou wide characters). Esses caracteres s√£o[m
[36m@@ -60,22 +61,22 @@[m [mEmojis[m
 [m
 \u1F600: üòÄ (carinha sorrindo)[m
 \u1F609: üòâ (carinha piscando)[m
[31m-\u2764: ‚ù§Ô∏è (cora√ß√£o)[m
[32m+[m[32m\u2764 : ‚ù§Ô∏è (cora√ß√£o)[m
 [m
 ----------------------------------------------------[m
 [m
[31m-## Considera√ß√µes sobre a evolu√ß√£o do suporte a codifica√ß√£o e a relev√¢ncia da linguagem C:[m
[32m+[m[32m##üìå Considera√ß√µes sobre a evolu√ß√£o do suporte a codifica√ß√£o e a relev√¢ncia da linguagem C:[m
 [m
 Linguagens mais modernas como Python, Java e JavaScript j√° oferecem suporte nativo ao sistema [m
 de codifica√ß√£o unicode, permitindo que a manipula√ß√£o de caracteres de diferentes idiomas seja [m
[31m-feita de maneira autom√°tica, em a necessidade de tipos espec√≠ficos, sendo geralmente uma quest√£o[m
[32m+[m[32mfeita de maneira autom√°tica, sem a necessidade de tipos espec√≠ficos, sendo geralmente uma quest√£o[m
 de configura√ß√£o no ambiente de edi√ß√£o. no entanto, isso n√£o torna a linguagem C obsoleta [m
 ou inutiliz√°vel. Pelo contr√°rio, ao considerar o contexto de sua cria√ß√£o, durante uma √©poca [m
[31m-de grandes transforma√ß√µes tecnol√≥gicas e guerras, a linguagem C foi um marco importante. [m
[32m+[m[32mde grandes transforma√ß√µes tecnol√≥gicas e guerras, e que n√£o pensavam que computadores e tecnologia[m
[32m+[m[32mn√£o fossem se tornar algo global, a linguagem C foi um marco importante em seu tempo.[m
 [m
 A evolu√ß√£o de C ao longo do tempo, incluindo tentativas de adapta√ß√£o a novos paradigmas [m
 (como o suporte Unicode e a configura√ß√£o de localidade via `locale.h`), demonstra sua[m
[31m-flexibilidade e resili√™ncia. A linguagem C continua sendo amplamente utilizada em sistemas [m
[31m-de baixo n√≠vel, embarcados e em √°reas onde performance e o controle direto sobre o hardware [m
[31m-s√£o cruciais.[m
[31m- [m
\ No newline at end of file[m
[32m+[m[32mflexibilidade, resili√™ncia e adaptabilidade. A linguagem C continua sendo amplamente[m[41m [m
[32m+[m[32mutilizada em sistemas de baixo n√≠vel, embarcados e em √°reas onde performance e o controle[m[41m [m
[32m+[m[32mdireto sobre o hardware s√£o cruciais.[m
[1mdiff --git a/estrutura_de_dados_e_algoritmos/1_estrutura_de_dados/2_estruturas_lineares/3_filas/2_Circular_Queue/1_filaCircularEstatica.c b/estrutura_de_dados_e_algoritmos/1_estrutura_de_dados/2_estruturas_lineares/3_filas/2_Circular_Queue/1_filaCircularEstatica.c[m
[1mindex 05821b9..cef6b22 100644[m
[1m--- a/estrutura_de_dados_e_algoritmos/1_estrutura_de_dados/2_estruturas_lineares/3_filas/2_Circular_Queue/1_filaCircularEstatica.c[m
[1m+++ b/estrutura_de_dados_e_algoritmos/1_estrutura_de_dados/2_estruturas_lineares/3_filas/2_Circular_Queue/1_filaCircularEstatica.c[m
[36m@@ -5,22 +5,22 @@[m
 [m
 /**[m
  * @brief Estrutura que representa uma fila circular.[m
[31m- * [m
[32m+[m[32m *[m
  * A fila circular √© uma estrutura de dados que mant√©m os elementos de forma[m
  * sequencial e se "dobra" quando o final √© alcan√ßado, tornando poss√≠vel reutilizar[m
  * os espa√ßos da fila que foram removidos, evitando a necessidade de mover elementos.[m
  */[m
 typedef struct fila[m
 {[m
[31m-    int frente;                 /**< √çndice do primeiro elemento na fila */[m
[31m-    int atras;                  /**< √çndice do √∫ltimo elemento na fila */[m
[31m-    int elementos[QUEUE_SIZE];   /**< Vetor que armazena os elementos da fila */[m
[31m-    int contador;               /**< N√∫mero de elementos na fila */[m
[32m+[m[32m    int frente;                /**< √çndice do primeiro elemento na fila */[m
[32m+[m[32m    int atras;                 /**< √çndice do √∫ltimo elemento na fila */[m
[32m+[m[32m    int elementos[QUEUE_SIZE]; /**< Vetor que armazena os elementos da fila */[m
[32m+[m[32m    int contador;              /**< N√∫mero de elementos na fila */[m
 } filaCircular;[m
 [m
 /**[m
  * @brief Verifica se a fila est√° vazia.[m
[31m- * [m
[32m+[m[32m *[m
  * @param queue Ponteiro para a estrutura filaCircular[m
  * @return Retorna true se a fila estiver vazia, caso contr√°rio, retorna false[m
  */[m
[36m@@ -31,7 +31,7 @@[m [mbool filaVazia(filaCircular *queue)[m
 [m
 /**[m
  * @brief Verifica se a fila est√° cheia.[m
[31m- * [m
[32m+[m[32m *[m
  * @param queue Ponteiro para a estrutura filaCircular[m
  * @return Retorna true se a fila estiver cheia, caso contr√°rio, retorna false[m
  */[m
[36m@@ -42,10 +42,10 @@[m [mbool filaCheia(filaCircular *queue)[m
 [m
 /**[m
  * @brief Insere um elemento na fila circular.[m
[31m- * [m
[32m+[m[32m *[m
  * A inser√ß√£o √© feita no final da fila. Quando a fila chega ao fim, ela come√ßa a[m
  * reutilizar os espa√ßos vagos no in√≠cio, tornando-se circular.[m
[31m- * [m
[32m+[m[32m *[m
  * @param queue Ponteiro para a estrutura filaCircular[m
  * @param elemento O valor a ser inserido na fila[m
  */[m
[36m@@ -65,10 +65,10 @@[m [mvoid inserirElementoNaFila(filaCircular *queue, int elemento)[m
 [m
 /**[m
  * @brief Remove um elemento da fila circular.[m
[31m- * [m
[32m+[m[32m *[m
  * O elemento removido ser√° o primeiro da fila, e a fila √© atualizada de forma[m
  * circular. Quando a remo√ß√£o √© feita, o √≠ndice "frente" √© ajustado.[m
[31m- * [m
[32m+[m[32m *[m
  * @param queue Ponteiro para a estrutura filaCircular[m
  * @return O elemento removido da fila, ou -1 se a fila estiver vazia[m
  */[m
[36m@@ -88,10 +88,10 @@[m [mint removerElementoNaFila(filaCircular *queue)[m
 [m
 /**[m
  * @brief Exibe os elementos presentes na fila circular.[m
[31m- * [m
[32m+[m[32m *[m
  * A fun√ß√£o exibe todos os elementos da fila, respeitando a estrutura circular.[m
  * Caso a fila esteja vazia, uma mensagem informando isso ser√° exibida.[m
[31m- * [m
[32m+[m[32m *[m
  * @param queue Ponteiro para a estrutura filaCircular[m
  */[m
 void exibirFila(filaCircular *queue)[m
[1mdiff --git a/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/1_busca_linear.c b/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/1_busca_linear.c[m
[1mindex ea73714..bf156dd 100644[m
[1m--- a/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/1_busca_linear.c[m
[1m+++ b/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/1_busca_linear.c[m
[36m@@ -4,9 +4,18 @@[m
 /**[m
  * @brief Fun√ß√£o de busca linear com contagem de compara√ß√µes[m
  *[m
[31m- * O algoritmo de busca linear percorre por todos os elementos do array,[m
[31m- * e vai verificando cada elemento at√© o alvo ser encontrado no array,[m
[31m- * contando o n√∫mero de compara√ß√µes feitas.[m
[32m+[m[32m * O algoritmo de busca linear percorre todos os elementos do array,[m
[32m+[m[32m * verificando cada um at√© encontrar o valor alvo ou terminar a busca,[m
[32m+[m[32m * contabilizando o n√∫mero de compara√ß√µes realizadas.[m
[32m+[m[32m *[m
[32m+[m[32m * Complexidade:[m
[32m+[m[32m * - Tempo:[m
[32m+[m[32m *   - Melhor caso: O(1)  -> quando o alvo est√° na primeira posi√ß√£o.[m
[32m+[m[32m *   - Pior caso:   O(n)  -> quando o alvo est√° na √∫ltima posi√ß√£o ou n√£o est√° presente.[m
[32m+[m[32m *   - Caso m√©dio:  O(n)  -> em m√©dia, o alvo est√° no meio do array.[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * - Espa√ßo:[m
[32m+[m[32m *   - O(1) -> usa apenas vari√°veis auxiliares; n√£o depende do tamanho do array.[m
  *[m
  * @param array Informar um array[m
  * @param size Informar o tamanho do array[m
[1mdiff --git a/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/2_busca_binaria.c b/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/2_busca_binaria.c[m
[1mindex 5cea76c..d0f6b5e 100644[m
[1m--- a/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/2_busca_binaria.c[m
[1m+++ b/estrutura_de_dados_e_algoritmos/2_algoritmos/1_buscas/2_busca_binaria.c[m
[36m@@ -37,12 +37,24 @@[m [m